----------------------------
-- FRONTLINES 4.0 RELEASE --
-- 		by CantFunkUp	  --
----------------------------

--== FRONTLINES VARIABLES ==--
declare global.number[0] with network priority high
declare global.number[1] with network priority low
declare global.number[2] with network priority low
declare global.number[3] with network priority low
declare global.number[4] with network priority low
declare global.object[0] with network priority low
declare global.object[1] with network priority low
declare global.object[3] with network priority low
declare global.object[4] with network priority low
declare global.number[5] with network priority local
declare global.number[6] with network priority low
declare global.number[7] with network priority local
declare global.number[8] with network priority local
declare global.timer[0] = 6
declare global.timer[1] = 720
declare global.team[0] with network priority low
declare global.player[0] with network priority low
declare global.player[1] with network priority low
declare object.timer[0] = script_option[3]
declare object.timer[1] = 3
declare object.timer[2] = 0
declare object.number[0] with network priority low
declare object.number[1] with network priority low
declare object.number[2] with network priority low
declare object.number[3] with network priority local
declare player.object[0] with network priority local
declare player.object[1] with network priority local
declare player.object[2] with network priority local
declare player.timer[0]
declare player.timer[1]
declare player.timer[2] = 4
declare player.player[0] with network priority local
declare player.number[0] with network priority low
declare player.number[1] with network priority local

declare global.number[9] with network priority local

alias phase = global.number[2]
alias phase_objective = global.number[3] -- 0 = both teams attacking, 1 = spartan team attacking, 2 = elite team attacking.
alias reds = object.number[0]
alias tryhard_weapon = object.number[0]
alias blues = object.number[1]
alias softkill_object = player.object[2]
alias capture_timer = object.timer[0]
alias music_timer = global.timer[0]
alias max_territories = global.number[4]
alias declared_sudden_death = global.number[5]
alias sudden_death_active = global.number[6]
alias temp_int = global.number[1]
alias temp_int2 = global.number[9]
alias primary_spawn_object = player.object[1]
alias temp_object = global.object[1]
alias temp_object2 = global.object[4]
alias danger_zone = object.object[0]
alias temp_team = global.team[0]
alias explosive = global.object[3]
alias bomb_carrier_player = global.player[0]
alias armed = object.number[0]
alias arm_timer = object.timer[1]
alias disarm_timer = object.timer[2]
alias class = object.number[0]
alias ability_timer = player.timer[0]
alias ability_cooldown = player.timer[1]
alias temp_player = global.player[1]
alias out_of_bounds = player.number[0]
alias heard_vo = player.number[1]
alias vo_timer = player.timer[2]

alias alpha_damage_traits = script_traits[0]
alias elite_major_traits = script_traits[1]
alias elite_spec_ops_traits = script_traits[2]
alias elite_ultra_traits = script_traits[3]
alias elite_royal_traits = script_traits[4]
alias elite_zealot_traits = script_traits[5]
alias spartan_marksman_traits = script_traits[6]
alias ability_overcharge_traits = script_traits[7]
alias ability_berserk_traits = script_traits[8]
alias spartan_juggernaut_traits = script_traits[9]
alias spartan_operator_traits = script_traits[10]
alias ability_fortify_traits = script_traits[11]
alias spartan_grenadier_traits = script_traits[12]
alias bravo_damage_traits = script_traits[13]
alias spartan_green_traits = script_traits[14]

--Loadout tier timers
do
	global.timer[1].set_rate(-100%)
	if global.timer[1] == 360 and global.number[8] == 0 then
		for each player do 
			current_player.set_loadout_palette(spartan_tier_2)
		end
		game.show_message_to(all_players, none, "Tier 2 loadouts available")
		global.number[8] = 1
	end
	if global.timer[1] == 359 and global.number[8] == 1 then
		global.number[8] = 0
	end
	if global.timer[1] == 0 and global.number[8] == 0 then
		for each player do
			current_player.set_loadout_palette(spartan_tier_3)
		end
	game.show_message_to(all_players, none, "Tier 3 loadouts available")
	global.number[8] = 1
	end
	for each player do
		current_player.biped.set_spawn_location_permissions(mod_player, current_player, 0)
	end
end

--VO
for each player do
	if current_player.heard_vo == 0 then
		current_player.vo_timer.set_rate(-100%)
		if current_player.vo_timer.is_zero() then
			send_incident(invasion_game_start, current_player, current_player)
			send_incident(terr_game_start, current_player, current_player)
			game.show_message_to(current_player, none, "Frontlines 4.0 release by CantFunkUp")
			current_player.heard_vo = 1
		end
	end
end

function reset_timers()
	global.object[0].capture_timer.reset()
	global.object[0] = no_object
	game.round_timer.reset()
	game.round_timer.set_rate(-100%)
	game.sudden_death_timer.reset()
	game.sudden_death_timer.set_rate(0%)
	sudden_death_active = 0
	declared_sudden_death = 0
end

function add_spartan_lives()
	if script_option[4] != 0 or script_option[4] != -1 then 
		team[0].score += script_option[4]
	end
	if script_option[4] == -1 then
		for each object with label "s_lives_added" do
			if current_object.spawn_sequence != 0 then
				team[0].score += current_object.spawn_sequence
				team[0].score += 1
			end
		end
	end
end

function add_elite_lives()
	if script_option[4] != 0 or script_option[4] != -1 then 
		team[1].score += script_option[4]
	end
	if script_option[4] == -1 then
		for each object with label "s_lives_added" do
			if current_object.spawn_sequence != 0 then
				team[1].score += current_object.spawn_sequence
				team[1].score += 1
			end
		end
	end
end

function del_danger_zones()
	for each object do
		if current_object.has_forge_label("frontline") or current_object.has_forge_label("frontline_spawnpoint") then
			current_object.danger_zone.delete()
		end
	end
end

function announce_defense_general()
	game.play_sound_for(current_player, announce_defense, false)
	current_player.set_round_card_title("Defense")
end

function announce_offense_terr_lost()
	game.play_sound_for(current_player, announce_territories_lost, false)
	game.play_sound_for(current_player, announce_offense, false)
	current_player.set_round_card_text("Offense")
	current_player.set_round_card_title("Territory lost!\r\nRegain the enemy territory.")
end

function announce_offense_defense_success()
	game.play_sound_for(current_player, announce_offense, false)
	current_player.set_round_card_text("Offense")
	current_player.set_round_card_title("Defense successful!\r\nAttack the enemy territory.")
end

function spartan_attack_success()
	reset_timers()
	del_danger_zones()
	for each player do
		if current_player.team == team[0] then
			game.play_sound_for(current_player, announce_territories_captured, false)
			announce_defense_general()
			current_player.set_round_card_title("Territory captured!\r\nPrepare for an enemy counter-attack.")
		end
		if current_player.team == team[1] then
			announce_offense_terr_lost()
		end
	end
	phase_objective = 2
	game.play_sound_for(all_players, inv_cue_spartan_win_1, true)
	add_spartan_lives()
end


function spartan_defense_success()
	reset_timers()
	del_danger_zones()
	for each player do
		if current_player.team == team[0] then
			announce_offense_defense_success()
		end
		if current_player.team == team[1] then
			announce_defense_general()
			current_player.set_round_card_title("Attack failed!\r\nPrepare for an enemy counter-attack.")
		end
	end
	phase_objective = 1
	if phase == max_territories then 
		game.play_sound_for(all_players, inv_cue_spartan_win_2, true)
		game.round_timer += 120
	alt
		game.play_sound_for(all_players, inv_cue_spartan_win_1, true)
	end
	add_spartan_lives()
end

function elite_attack_success()
	reset_timers()
	del_danger_zones()
	for each player do
		if current_player.team == team[0] then
			announce_offense_terr_lost()
		end
		if current_player.team == team[1] then
			game.play_sound_for(current_player, announce_territories_captured, false)
			announce_defense_general()
			current_player.set_round_card_title("Territory captured!\r\nPrepare for an enemy counterattack.")
		end
	end
	phase_objective = 1
	game.play_sound_for(all_players, inv_cue_covenant_win_1, true)
	add_elite_lives()
end

function elite_defense_success()
	reset_timers()
	del_danger_zones()
	for each player do
		if current_player.team == team[0] then
			announce_defense_general()
			current_player.set_round_card_title("Attack failed!\r\nPrepare for an enemy counter-attack.")
		end
		if current_player.team == team[1] then
			announce_offense_defense_success()
		end
	end
	phase_objective = 2
	if phase == 1 then
		game.play_sound_for(all_players, inv_cue_covenant_win_2, true)
		game.round_timer += 120
	alt
		game.play_sound_for(all_players, inv_cue_covenant_win_1, true)
	end
	add_elite_lives()
end	

function prepare_game_over()
	phase_objective = -1
	game.round_timer.set_rate(0%)
	music_timer.set_rate(-100%)
end

function spartan_victory()
	temp_team = team[0]
	game.play_sound_for(all_players, inv_cue_spartan_win_big, true)
	prepare_game_over()
	team[1].score = 0
end

function elite_victory()
	temp_team = team[1]
	game.play_sound_for(all_players, inv_cue_covenant_win_big, true)
	prepare_game_over()
	team[0].score = 0
end

function ticket_victory()
	for each player do
		if current_player.team == temp_team then
			current_player.set_round_card_text("Victory!")
			current_player.set_round_card_title("The enemy has run out of\r\nreinforcements and is forced to retreat.")
		end
		if current_player.team != temp_team then
			current_player.set_round_card_text("Defeat!")
			current_player.set_round_card_title("We have run out of reinforcements\r\n and are forced to retreat.")
		end
	end
end

function capture_victory()
	for each player do
		if current_player.team == temp_team then
			current_player.set_round_card_text("Victory!")
			current_player.set_round_card_title("We have destroyed the enemy HQ!")
		end
		if current_player.team != temp_team then
			current_player.set_round_card_text("Defeat!")
			current_player.set_round_card_title("Our HQ has been lost!")
		end
	end
end

function start_sudden_death()
	if declared_sudden_death == 0 then
		game.play_sound_for(all_players, announce_sudden_death, false)
		declared_sudden_death = 1
	end
	game.sudden_death_timer.set_rate(-100%)
	sudden_death_active = 1
end

function negative_scaling_timers()
	if script_option[5] == 0 and temp_int > 0 then
		global.object[0].timer[0].set_rate(-100%)
	end
	if script_option[5] == 1 then
		if temp_int == 1 then
			global.object[0].timer[0].set_rate(-50%)
		end
		if temp_int == 2 then
			global.object[0].timer[0].set_rate(-75%)
		end
		if temp_int == 3 then
			global.object[0].timer[0].set_rate(-100%)
		end
		if temp_int == 4 then
			global.object[0].timer[0].set_rate(-125%)
		end
		if temp_int == 5 then
			global.object[0].timer[0].set_rate(-150%)
		end
		if temp_int == 6 then
			global.object[0].timer[0].set_rate(-175%)
		end
		if temp_int >= 7 then
			global.object[0].timer[0].set_rate(-200%)
		end
	end
end

function positive_scaling_timers()
	if script_option[5] == 0 and temp_int > 0 then
		global.object[0].timer[0].set_rate(100%)
	end
	if script_option[5] == 1 then
		if temp_int == 1 then
			global.object[0].timer[0].set_rate(50%)
		end
		if temp_int == 2 then
			global.object[0].timer[0].set_rate(75%)
		end
		if temp_int == 3 then
			global.object[0].timer[0].set_rate(100%)
		end
		if temp_int == 4 then
			global.object[0].timer[0].set_rate(125%)
		end
		if temp_int == 5 then
			global.object[0].timer[0].set_rate(150%)
		end
		if temp_int == 6 then
			global.object[0].timer[0].set_rate(175%)
		end
		if temp_int >= 7 then
			global.object[0].timer[0].set_rate(200%)
		end
	end
end

function check_danger_zone()
	if current_object.team == team[0] and temp_object.blues <= 0 then
		current_object.set_spawn_location_permissions(allies)
	end
	if current_object.team == team[0] and temp_object.blues > 0 then
		current_object.set_spawn_location_permissions(no_one)
	end
	if current_object.team == team[1] and temp_object.reds <= 0 then
		current_object.set_spawn_location_permissions(allies)
	end
	if current_object.team == team[1] and temp_object.reds > 0 then
		current_object.set_spawn_location_permissions(no_one)
	end
end

-- Init stuff
do 
	if global.number[0] == 0 then 
		phase = -1
		for each team do 
			if global.number[0] == 0 then
				if script_option[0] == -1 then
					for each object with label "s_lives" do 
						temp_int = current_object.spawn_sequence
						temp_int *= 10
						current_team.score = temp_int
					end
				altif script_option[0] == 1 then -- This block and the one below it are here because the script_option values cannot exceed 511.
					current_team.score = 750
				altif script_option[0] == 2 then
					current_team.score = 1000
				alt
				current_team.score = script_option[0]
				end
			end
			for each player do
				if current_player.team == team[0] then 
					current_player.set_round_card_text("UNSC")
					current_player.set_round_card_title("Capture territories to advance the frontline.")
				end
				if current_player.team == team[1] then 
					current_player.set_round_card_text("Insurrectionists")
					current_player.set_round_card_title("Capture territories to advance the frontline.")
				end
			end
		end 
		for each object with label "frontline" do 
			max_territories += 1 
		end
		global.number[0] = 1
	end
end

-- Sudden death
do
	if sudden_death_active == 1 then 
		if game.sudden_death_timer.is_zero() then
			if phase_objective == 1 then
				del_danger_zones()
				elite_defense_success()
			alt
				del_danger_zones()
				spartan_defense_success()
			end
		end
		if phase_objective == 1 and global.object[0].reds == 0 then
			if script_option[3] != -1 and global.object[0].capture_timer == script_option[3] then --I've just realized I don't think this is working as intended
				del_danger_zones()
				elite_defense_success()
			end
			if script_option[3] == -1 and global.object[0].capture_timer == global.object[0].number[3] then
				del_danger_zones()
				elite_defense_success()
			end
		end
		if phase_objective == 2 and global.object[0].blues == 0 then
			if script_option[3] != -1 and global.object[0].capture_timer == script_option[3] then 
				del_danger_zones()
				spartan_defense_success()
			end
			if script_option[3] == -1 and global.object[0].capture_timer == global.object[0].number[3] then
				del_danger_zones()
				spartan_defense_success()
			end
		end
	end
end

-- Assign loadouts depending on which team the player is on, and display the appropriate round title card.
for each player do
	if global.timer[1] > 360 then
		current_player.set_loadout_palette(spartan_tier_1)
		current_player.set_round_card_icon(invasion)
	altif global.timer[1] > 0 then 
		current_player.set_loadout_palette(spartan_tier_2)
	alt
		current_player.set_loadout_palette(spartan_tier_3)
	end

end

-- Turns on coop spawning to allow respawning at territories.
for each team do
	current_team.set_co_op_spawning(true)
end

for each object with label "pregame" do 
	current_object.delete()
end

-- Determines who is attacking first if the option is set to "Map default"
if phase == -1 then
	if script_option[1] == -1 then
		for each object with label "s_first_attack" do
			if current_object.spawn_sequence == 0 then 
				phase_objective = 0
			end
			if current_object.spawn_sequence == 1 then
				phase_objective = 1 
			end
			if current_object.spawn_sequence == 2 then 
				phase_objective = 2 
			end
		end
	end
	if script_option[1] == 0 then -- If "First Attack" is set to "Both"
		phase_objective = 0
	end
	if script_option[1] == 1 then -- If "First Attack" is set to "Spartans"
		phase_objective = 1 
	end
	if script_option[1] == 2 then -- If "First Attack" is set to "Elites"
		phase_objective = 2 
	end
end

-- Determines what to do when the game starts
do 
	if phase == -1 then 
		if phase_objective == 0 then -- Neutral territory must be captured to determine who is attacking first.
			for each object with label "frontline" do 
				if current_object.team != team[0] and current_object.team != team[1] then
					send_incident(team_offense, all_players, all_players)
					phase = current_object.spawn_sequence
				end
			end
		end
		if phase_objective == 1 then -- Spartans are attacking first. Gets the elite territory closest to the frontline.
			phase = 511
			for each object with label "frontline" do 
				if current_object.spawn_sequence < phase and current_object.team == team[1] then 
					phase = current_object.spawn_sequence
				end
			end
		end
		if phase_objective == 2 then -- Elites are attacking first. Gets the spartan territory closest to the frontline.
			for each object with label "frontline" do
				if current_object.spawn_sequence > phase and current_object.team == team[0] then 
					phase = current_object.spawn_sequence
				end
			end
		end
	end
end

--Get current frontline and set it up
for each object with label "frontline" do
	if phase == current_object.spawn_sequence then -- Figures out what territory is being fought over, and displays a marker over it.
		global.object[0] = current_object
		global.object[0].set_waypoint_visibility(everyone)
		global.object[0].set_waypoint_icon(inward)
		current_object.set_waypoint_timer(object.capture_timer)
		global.object[0].reds = 0
		global.object[0].blues = 0
		if global.object[0].danger_zone == no_object then -- Sets up a danger zone that is used enemies are near the frontline.
			global.object[0].danger_zone = global.object[0].place_at_me(hill_marker, none, never_garbage_collect, 0, 0, 0, default)
			temp_object = global.object[0].danger_zone
			temp_object.team = global.object[0].team
			temp_object.set_shape(cylinder, 150, 150, 150)
		end
		temp_object = global.object[0].danger_zone
		temp_object.reds = 0
		temp_object.blues = 0
		for each player do -- Counts the number of players from each side who are in the territory.
			if global.object[0].shape_contains(current_player.biped) then
				if current_player.team == team[0] then
					global.object[0].reds += 1
				end
				if current_player.team == team[1] then
					global.object[0].blues += 1
				end
			end
			if temp_object.shape_contains(current_player.biped) then
				if current_player.team == team[0] then
					temp_object.reds += 1
				end
				if current_player.team == team[1] then
					temp_object.blues += 1
				end
			end
			-- If the danger zone is clear of enemies they can spawn at the frontline, otherwise they can't
			check_danger_zone()
		end
	end
	if phase != current_object.spawn_sequence then
		current_object.set_waypoint_visibility(no_one)
		if script_option[7] == 0 then
			temp_int = phase
			temp_int -= 1
			temp_int2 = phase
			temp_int2 += 1
			if current_object.spawn_sequence == temp_int or current_object.spawn_sequence == temp_int2 then
				for each player do
					if current_player.team == current_object.team then
						current_object.set_spawn_location_permissions(mod_player, current_player, 1)
					end
				end
			end
			if current_object.spawn_sequence != temp_int and current_object.spawn_sequence != temp_int2 then
				current_object.set_spawn_location_permissions(no_one)
			end
		end
		if script_option[7] == 1 then
			current_object.set_spawn_location_permissions(allies)
		end
	end
end

--Set up primary respawn points for players.
for each player do
	temp_object = no_object
	temp_object2 = no_object
	if current_player.team == team[0] then
		for each object with label "frontline" do
			if current_object.team == current_player.team and current_object.spawn_sequence > temp_object.spawn_sequence then
				temp_object = current_object
				if current_object.spawn_sequence == phase then
					temp_object2 = current_object.danger_zone
					if temp_object2.blues == 0 then
						current_player.set_primary_respawn_object(current_object)
					end
				alt
					current_player.set_primary_respawn_object(current_object)
				end
			end
		end
	end
	if current_player.team == team[1] then
		for each object with label "frontline" do
			if temp_object.spawn_sequence != 0 then
				if current_object.team == current_player.team and current_object.spawn_sequence < temp_object.spawn_sequence then
					temp_object = current_object
					if current_object.spawn_sequence == phase then
						temp_object2 = current_object.danger_zone
						if temp_object2.reds == 0 then
							current_player.set_primary_respawn_object(current_object)
						end
					alt
						current_player.set_primary_respawn_object(current_object)
					end
				end
			end
			if temp_object.spawn_sequence == 0 and current_object.team == current_player.team then
				temp_object = current_object
				current_player.set_primary_respawn_object(current_object)
			end
		end
	end
end

-- Allow multiple spawnpoints for one frontline
for each object with label "frontline_spawnpoint" do
	temp_object = current_object
	for each object with label "frontline" do
		if temp_object.spawn_sequence == current_object.spawn_sequence then
			temp_object.team = current_object.team
		end
	end
	if phase == current_object.spawn_sequence then
		if current_object.danger_zone == no_object then -- Sets up a danger zone that checks if enemies are near the spawnpoint.
			current_object.danger_zone = current_object.place_at_me(hill_marker, none, never_garbage_collect, 0, 0, 0, default)
			temp_object = no_object
			temp_object = current_object.danger_zone
			temp_object.team = current_object.team
			temp_object.set_shape(cylinder, 150, 150, 150)
		end
		temp_object = no_object
		temp_object = current_object.danger_zone
		temp_object.reds = 0
		temp_object.blues = 0
		for each player do -- Counts the number of players from each side who are in the danger zone.
			if temp_object.shape_contains(current_player.biped) then
				if current_player.team == team[0] then
					temp_object.reds += 1
				end
				if current_player.team == team[1] then
					temp_object.blues += 1 
				end 
			end
		end -- If the danger zone is clear of enemies they can spawn at the frontline spawnpoints, otherwise they can't
		check_danger_zone()
	end
	if script_option[7] == 0 then -- If "Spawn Locations" is set to "Current frontline and HQ"
		temp_int = phase
		temp_int -= 1
		temp_int2 = phase
		temp_int2 += 1
		if current_object.spawn_sequence == temp_int or current_object.spawn_sequence == temp_int2 then
			current_object.set_spawn_location_permissions(allies)
		end
		if current_object.spawn_sequence != temp_int and current_object.spawn_sequence != temp_int2 then
			current_object.set_spawn_location_permissions(no_one)
		end
	end
	if script_option[7] == 1 then -- If "Spawn Locations" is set to "Everywhere"
		if current_object.spawn_sequence != phase then
			current_object.set_spawn_location_permissions(allies)
		end
	end
end

-- Both teams will always be able to spawn at their HQ. This is so they have somewhere to spawn if their last territory is being attacked.
for each object with label "hq" do 
	for each player do
		if current_object.team == current_player.team then 
			current_object.set_spawn_location_permissions(mod_player, current_player, 1)
		alt
			current_object.set_spawn_location_permissions(mod_player, current_player, 0)
		end
	end
end

--Frontline objective logic
do
	if phase_objective == 0 then -- If both teams are attacking
		game.round_timer.set_rate(0%)
		if global.object[0].reds > global.object[0].blues then -- If there are more spartans than elites
			global.object[0].capture_timer.set_rate(-100%) 
			if global.object[0].timer[0].is_zero() then -- Initiates a Spartan victory
				global.object[0].team = team[0]
				global.object[0].timer[0].reset()
				del_danger_zones()
				spartan_attack_success()
			end
		altif global.object[0].blues > global.object[0].reds then -- if there are more elites than spartans
			global.object[0].timer[0].set_rate(-100%)
			if global.object[0].timer[0].is_zero() then -- Initiates an Elite victory.
				global.object[0].team = team[1]
				del_danger_zones()
				elite_attack_success()
			end
		altif global.object[0].timer[0] != script_option[3] then -- If no Spartan or Elites are in the territory, it will automatically regenerate up to 20.
			global.object[0].timer[0].set_rate(100%)
		alt
			global.object[0].timer[0].set_rate(0%)
		end
	end
	if phase_objective == 1 and phase != max_territories then -- If the spartans are attacking
		if global.object[0].reds > global.object[0].blues then --If there are more spartans than Elites, the capture timer will go down.
			temp_int = global.object[0].reds
			temp_int -= global.object[0].blues
			negative_scaling_timers()
			if global.object[0].timer[0].is_zero() then
				global.object[0].team = team[0]
				global.object[0].timer[0].reset()
				del_danger_zones()
				if phase == max_territories then -- If this is the last territory, the game will end with a Spartan victory.
					spartan_victory()
					capture_victory()
				alt
					spartan_attack_success()
				end
			end
		altif global.object[0].blues > global.object[0].reds and global.object[0].timer[0] != script_option[3] then -- If there are more Elites than Spartans in the territory, the timer will regenerate up to the set amount.
			temp_int = global.object[0].blues
			temp_int -= global.object[0].reds
			positive_scaling_timers()
		alt 
			global.object[0].timer[0].set_rate(0%)
		end
		if game.round_time_limit > 0 and game.round_timer.is_zero() and global.object[0].reds <= 0 then -- If no Spartans are in the territory when the round timer ends then they will fail the attack.
			del_danger_zones()
			global.object[0] = no_object
			phase -= 1
			elite_defense_success()
		end
		if game.round_time_limit > 0 and game.round_timer.is_zero() and global.object[0].reds > 0 then -- If the round timer reaches 0 but there is at least 1 Spartan in the territory, sudden death will start.
			start_sudden_death()
		end
		if global.object[0].reds > 0 then 
			global.object[0].set_waypoint_priority(blink)
		alt
			global.object[0].set_waypoint_priority(high)
		end
	end
	if phase_objective == 2 and phase != 1 then -- If the elites are attacking
		if global.object[0].blues > global.object[0].reds then --If there are more elites than spartans
			temp_int = global.object[0].blues
			temp_int -= global.object[0].reds
			negative_scaling_timers()
			if global.object[0].timer[0].is_zero() then -- Initiates an Elite victory
				global.object[0].team = team[1]
				global.object[0].timer[0].reset()
				del_danger_zones()
				if phase == 1 then -- If this is the last territory, the game will end with an Elite victory.
					elite_victory()
					capture_victory()
				alt
					elite_attack_success()
				end
			end
		altif global.object[0].reds > global.object[0].blues and global.object[0].timer[0] != script_option[3] then --If there are more Spartans than Elites in the territory, the timer will regenerate up to 20.
			temp_int = global.object[0].reds
			temp_int -= global.object[0].blues
			positive_scaling_timers()
		alt 
			global.object[0].timer[0].set_rate(0%)
		end
		if game.round_time_limit > 0 and game.round_timer.is_zero() and global.object[0].blues <= 0 then -- If no elites are in the territory when the round timer ends then they will fail the attack.
			del_danger_zones()
			global.object[0] = no_object
			phase += 1
			spartan_defense_success()
		end
		if game.round_time_limit > 0 and game.round_timer.is_zero() and global.object[0].blues > 0 then  -- If the round timer reaches 0 but there is at least 1 Elite in the territory, sudden death will start.
			start_sudden_death()
		end
		if global.object[0].blues > 0 then 
			global.object[0].set_waypoint_priority(blink)
		alt
			global.object[0].set_waypoint_priority(high)
		end
	end
end

-- Capture progress bar for people in the territory
for each player do
	if global.object[0].shape_contains(current_player.biped) then
		global.object[0].set_progress_bar(object.capture_timer, mod_player, current_player, 1)
	end
end

-- Dynamic kill zones
function attach_soft_kill()
    current_player.softkill_object = current_player.biped.place_at_me(soft_kill_boundary, none, never_garbage_collect, 0, 0, 0, none)
    current_player.softkill_object.set_shape(sphere, 2)
    current_player.softkill_object.attach_to(current_player.biped, 0, 0, 0, absolute)
    temp_object = current_player.softkill_object
end

for each player do
	current_player.out_of_bounds = 0
	for each object with label "killzone" do
        if current_object.shape_contains(current_player.biped) then
            if current_player.softkill_object == no_object and current_player.team == team[0] and current_object.spawn_sequence > phase then
				current_player.out_of_bounds += 1
            end
            if current_player.softkill_object == no_object and current_player.team == team[1] and current_object.spawn_sequence < phase then
                current_player.out_of_bounds += 1
            end
        end
    end
	if current_player.out_of_bounds > 0 then
		attach_soft_kill()
		if current_player.team == team[0] then
			temp_object.team = team[1]
		alt
			temp_object.team = team[0]
		end
	end
	if current_player.out_of_bounds == 0 and current_player.softkill_object != no_object then
		current_player.softkill_object.delete()
	end
end

-- Assault
if phase == max_territories or phase == 1 then
	if explosive == no_object then
		temp_int = phase
		if phase_objective == 1 then
			temp_int -= 1
		end
		if phase_objective == 2 then
			temp_int += 1
		end
		for each object with label "frontline" do
			if current_object.spawn_sequence == temp_int then
				explosive = current_object.place_at_me(bomb, none, never_garbage_collect, 0, 0, 2, none)
				explosive.team = current_object.team
				explosive.set_weapon_pickup_priority(high)
				explosive.set_waypoint_icon(bomb)
				explosive.set_waypoint_priority(high)
				explosive.set_waypoint_visibility(everyone)
				explosive.set_invincibility(1)
				explosive.set_pickup_permissions(allies)
			end
		end
	end
	if explosive != no_object and explosive.is_out_of_bounds() then
		explosive.delete()
		send_incident(bomb_reset, team[0], all_players)
	end
	if bomb_carrier_player == no_player then
		bomb_carrier_player = explosive.try_get_carrier()
		if bomb_carrier_player != no_player then
			send_incident(bomb_taken, bomb_carrier_player, bomb_carrier_player)
		end
	end
	if bomb_carrier_player != no_player then
		bomb_carrier_player = explosive.try_get_carrier()
		if bomb_carrier_player == no_player then
			send_incident(bomb_dropped, team[0], team[0])
		end
	end
	for each player do
		if current_player == bomb_carrier_player then
			current_player.biped.set_waypoint_icon(defend)
		end
		if current_player != bomb_carrier_player then
			current_player.biped.set_waypoint_icon(none)
		end
	end
	global.object[0].armed = 0
	if global.object[0].shape_contains(bomb_carrier_player.biped) then
		global.object[0].arm_timer.set_rate(-100%)
		global.object[0].set_progress_bar(object.arm_timer, everyone)
	end
	if not global.object[0].shape_contains(bomb_carrier_player.biped) and global.object[0].object[1] == no_object then
		global.object[0].arm_timer.set_rate(100%)
	end
	if global.object[0].arm_timer.is_zero() then
		send_incident(bomb_armed, bomb_carrier_player, all_players)
		send_incident(bomb_planted, bomb_carrier_player, bomb_carrier_player)
		bomb_carrier_player = no_player
		explosive.detach()
		explosive.attach_to(global.object[0], 0, 0, 2, absolute)
		explosive.set_pickup_permissions(no_one)
		global.object[0].object[1] = explosive
		global.object[0].set_progress_bar(object.capture_timer, everyone)
		global.object[0].arm_timer.reset()
	end
	if global.object[0].object[1] != no_object then
		for each player do
			if global.object[0].shape_contains(current_player.biped) and current_player.team == global.object[0].team then
				global.object[0].number[0] = 1
			end
		end
		if global.object[0].number[0] == 1 then
			global.object[0].timer[0].set_rate(0%)
			global.object[0].disarm_timer.set_rate(100%)
		end
		if global.object[0].number[0] == 0 then
			global.object[0].timer[0].set_rate(-100%)
			global.object[0].disarm_timer.set_rate(-100%)
		end
		if global.object[0].disarm_timer == 5 then
			send_incident(bomb_disarmed, team[1], all_players)
			explosive.delete()
			global.object[0].disarm_timer.reset()
			global.object[0].capture_timer.reset()
		end
		if global.object[0].timer[0].is_zero() then
			send_incident(bomb_detonated, team[0], all_players)
			explosive.set_invincibility(0)
			explosive.kill(false)
			explosive.delete()
			if phase_objective == 1 then
				spartan_victory()
			end
			if phase_objective == 2 then
				elite_victory()
			end
			capture_victory()
		end
	end
	if game.round_time_limit > 0 and game.round_timer.is_zero() then
		del_danger_zones()
		explosive.delete()
		if phase == max_territories then
			phase -= 1
			elite_defense_success()
		end
		if phase == 1 then
			phase += 1
			spartan_defense_success()
		end
	end
end

-- Depletes tickets if the game isn't over
for each player do 
	if current_player.killer_type_is(kill|guardians) and music_timer == 6 then
		if current_player.team == team[0] then 
			team[0].score -= 1 
		end
		if current_player.team == team[1] then
			team[1].score -= 1 
		end
	end
end

-- When tickets for a team are depleted, end the game, and have the other team win
do
	if team[0].score <= 0 and phase_objective != -1 and script_option[2] == 0 then
		elite_victory()
		ticket_victory()
	end
	if team[1].score <= 0 and phase_objective != -1 and script_option[2] == 0 then
		spartan_victory()
		ticket_victory()
	end
end

-- Ends the game after you get to hear the cool music 
do
	if music_timer.is_zero() then 
		game.end_round()
	end
end

-- Damage boost
for each player do
	temp_object = current_player.try_get_vehicle()
	temp_object2 = current_player.try_get_weapon(primary)
	if temp_object.has_forge_label("damage_boost") or temp_object2.has_forge_label("damage_boost") then
		current_player.apply_traits(bravo_damage_traits)
	end	
end

--=== CLASS SYSTEM ===--

enum class
    none
    minor 
    spec_ops 
    major 
    ultra 
    royal_zealot 
    zealot 
    guard 
    corpsman 
    operator 
    grenadier 
    marksman 
    juggernaut 
end

function save_player_info()
    current_player.object[0] = current_player.try_get_weapon(primary)
    current_player.object[1] = current_player.try_get_weapon(secondary)
    current_player.biped.remove_weapon(primary, false)
    current_player.biped.remove_weapon(secondary, false)
    temp_object = current_player.biped
end

function apply_player_info()
    current_player.set_biped(temp_object2)
    temp_object.delete()
    current_player.biped.remove_weapon(primary, true)
    current_player.biped.remove_weapon(secondary, true)
    current_player.add_weapon(current_player.object[0])
    current_player.add_weapon(current_player.object[1])
end

-- Class detection
--TODO: make this optional
for each player do
	current_player.player[0] = no_player
    if current_player.biped != no_object then
		temp_object2 = current_player.biped
		if temp_object2.class == class.none then
			temp_object = current_player.try_get_weapon(primary)
			if temp_object.is_of_type(grenade_launcher) then
				temp_object2.class = class.grenadier
				game.show_message_to(current_player, none, "Grenadier selected: Grenades regenerate")
			end
			if temp_object.is_of_type(magnum) then
				temp_object = current_player.try_get_armor_ability()
				if temp_object.is_of_type(sprint) then
					temp_object2.class = class.grenadier
					game.show_message_to(current_player, none, "Grenadier selected: Grenades regenerate")
				alt
					temp_object2.class = class.corpsman
					game.show_message_to(current_player, none, "Corpsman selected: Passivley fortify allies giving them extra damage resistance")
				end
			end
			if temp_object.is_of_type(dmr) then
				temp_object2.class = class.marksman
				temp_object.tryhard_weapon = 1
				game.show_message_to(current_player, none, "Marksman selected: 2x radar range")
			end
			if temp_object.is_of_type(detached_machine_gun_turret) then
				temp_object2.class = class.juggernaut
			end
			temp_object = current_player.try_get_armor_ability()
			if temp_object.is_of_type(sprint) then
				temp_object2.class = class.guard
			end
			if temp_object.is_of_type(hologram) then
				temp_object2.class = class.operator
				game.show_message_to(current_player, none, "Operator selected: Faster movement speed")
			end
			--Fallback class
			if temp_object2.class == class.none then
				temp_object2.class = class.guard
			end
		end
    end
	temp_object = current_player.biped
	if temp_object.class == class.marksman then
        current_player.apply_traits(spartan_marksman_traits)
    end
    if temp_object.class == class.operator then
        current_player.apply_traits(spartan_operator_traits)
    end
    if temp_object.class == class.corpsman then
        temp_object.set_shape(cylinder, 23, 23, 23)
		temp_player = current_player
		temp_int = 0
		current_player.apply_traits(spartan_green_traits)
        for each player do
            if temp_object.shape_contains(current_player.biped) and current_player.team == temp_player.team then
				current_player.player[0] = temp_player
                current_player.apply_traits(ability_fortify_traits)
				script_widget[2].set_visibility(current_player, true)
				script_widget[2].set_text("Fortified\r\n+10%% Damage resistance and \r\nfaster shield recharge", hud_player.player[0])
				if current_player != temp_player then
					temp_int += 1
				end
			end
        end
		-- if temp_int > 0 then
		-- 	script_widget[3].set_visibility(temp_player, true)
		-- 	script_widget[3].set_text("Fortifying allies")
		-- end
    end
    if temp_object.class == class.grenadier then
        current_player.apply_traits(spartan_grenadier_traits)
    end  
	if temp_object.class == class.guard then
		current_player.apply_traits(spartan_green_traits)
	end
	if temp_object.class == class.juggernaut then
		current_player.biped.set_scale(120)
		temp_object2 = current_player.try_get_weapon(primary)
		if temp_object2.is_of_type(detached_machine_gun_turret) then
			current_player.apply_traits(spartan_juggernaut_traits)
		end
		if not temp_object2.is_of_type(detached_machine_gun_turret) then
			current_player.apply_traits(spartan_green_traits)
		end
	end
end

-- Anti-tryhard
if script_option[6] == 1 then
	for each player do
		temp_object = current_player.biped
		if temp_object.class != class.marksman then
			for each object do
				if current_object.is_of_type(dmr) and current_object.tryhard_weapon == 1 then
					current_object.set_pickup_permissions(mod_player, current_player, 0)
				end
			end
		end
		temp_object = current_player.biped
		temp_object2 = current_player.try_get_weapon(primary)
		if temp_object.class == class.marksman and temp_object2 != no_object then
			if not temp_object2.is_of_type(dmr) and not temp_object2.is_of_type(magnum) then
				current_player.biped.remove_weapon(primary, false)
				game.show_message_to(current_player, none, "Weapon prohibited")
			end
		end
	end
end

-- Troop vehicles
for each object with label "troop" do
	current_object.set_spawn_location_permissions(allies)
	temp_int = current_object.health
	temp_int *= 3
	current_object.health = temp_int
	temp_object = current_object
	for each object do
		temp_int = current_object.get_distance_to(temp_object)
		if temp_int == 0 and not current_object.is_of_type(spartan) and not current_object.is_of_type(elite) then
			current_object.delete()
		end
	end
end

-- Plasma Rifle buff
for each player do
	if script_option[8] == 1 then
		temp_object = current_player.try_get_weapon(primary)
		if temp_object.is_of_type(plasma_rifle) then
			current_player.apply_traits(alpha_damage_traits)
		end
	end
end

---== ANVIL EDITOR 1.1 ==---
-- this is sort of a mess cause I tried merging the anvil stuff with 330x stuff
-- it works but idk what's going on here tbh

for each object with label "scale" do
	-- Pink team invincibility
	-- I think this was supposed to make objects invincible at least, 
	-- but it doesn't seem like Weesee added that to these standalone scripts.
	if current_object.team == team[7] then
		current_object.set_invincibility(1)
	end
end

------------------------------------------
--Aliases to adjust to your own gametype--
------------------------------------------ 

alias shadow_parent = object.object[2] --The Shadow Object caster parent object

--== 330x VARIABLES ==--
declare global.number[11] with network priority local
declare object.number[5] with network priority local
declare global.object[5] with network priority local
alias temp_num0 = temp_int
alias temp_num1 = temp_int2
alias temp_num2 = global.number[11]
alias temp_obj0 = temp_object
alias obj_scale = object.number[5]
alias master_hill_marker = global.object[5]
alias recursions = temp_num0
alias anchor = temp_obj0

 --== 330x ==--
 for each object do
	if master_hill_marker == no_object then
	   master_hill_marker = current_object.place_at_me(hill_marker, none, none, -127,127,-127, none)		-- make master hill marker hidden underground
	end
 end
 
 function optimized_330x()
	if recursions > 0 then 
	   recursions -= 1
	   temp_num2 = current_object.obj_scale
	   temp_num2 /= 33
	   temp_num1 = current_object.obj_scale
	   temp_num1 /= 228
	   current_object.obj_scale += temp_num2
	   current_object.obj_scale += temp_num1
	   optimized_330x()
	end
 end

------------------------------------------
--Aliases to adjust to your own gametype--
------------------------------------------ 
alias civilian_obj = global.object[7]
alias gauss_shade = global.object[13]
alias spawner_obj = global.object[12]

-----------------------------------------------------------------------------------------
--Variable declarations based on aliases. Do not alter the network priorities of these!--
-----------------------------------------------------------------------------------------

declare civilian_obj with network priority low
declare gauss_shade with network priority low
declare spawner_obj with network priority low

--------
--Code--
--------

for each object with label "spawner" do --Spawns random stuff
	if current_object.object[0] == no_object then
		if current_object.spawn_sequence == 7 then
			current_object.object[0] = current_object.place_at_me(spartan, none, never_garbage_collect, 0, 0, 0, player_skull) --Spartan
		end
		if current_object.spawn_sequence == 8 then
			current_object.object[0] = current_object.place_at_me(elite, none, never_garbage_collect, 0, 0, 0, jetpack) --Elite
		end
		if current_object.spawn_sequence == 9 then
			current_object.object[0] = current_object.place_at_me(particle_emitter_fire, none, never_garbage_collect, 0, 0, 0, jetpack) --Elite
		end
		if current_object.spawn_sequence == 10 then
			current_object.object[0] = current_object.place_at_me(pelican_scenery, none, never_garbage_collect, 0, 0, 0, none) --scenery pelican with turret
			current_object.object[0].attach_to(current_object, 0, 0, 0, relative)
			current_object.object[0].detach()
		end
		if current_object.spawn_sequence == 11 then
			current_object.object[0] = current_object.place_at_me(phantom_scenery, none, never_garbage_collect, 0, 0, 0, none) --scenery phantom with turret
			current_object.object[0].attach_to(current_object, 0, 0, 0, relative)
			current_object.object[0].detach()
		end
		if current_object.spawn_sequence == 12 then
			current_object.object[0] = current_object.place_at_me(warthog_turret, none, never_garbage_collect, 0, 0, 0, none) --Warthog turret
		end
		if current_object.spawn_sequence == 13 then
			current_object.object[0] = current_object.place_at_me(warthog_turret_gauss, none, never_garbage_collect, 0, 0, 0, none) --Gauss Turret
			if current_object.team == team[1] then
				current_object.object[1] = current_object.place_at_me(flag_stand, none, never_garbage_collect, 0, 0, 0, none)
				current_object.object[2] = current_object.place_at_me(shade, none, never_garbage_collect, 0, 0, 0, none)
				current_object.object[2].set_shape(cylinder, 10, 10, 0)
				global.object[13] = current_object.object[2]
				for each object do
					if global.object[13].shape_contains(current_object) and current_object.is_of_type(shade_gun_plasma) then
						current_object.delete()
					end
				end
				current_object.object[2].set_scale(30)
				current_object.object[1].set_scale(1)
				current_object.object[2].attach_to(current_object.object[0], 0, 0, 0, relative)
				current_object.object[2].detach()
				current_object.object[1].attach_to(current_object.object[2], 0, 0, 0, relative)
				current_object.object[0].attach_to(current_object.object[1], 0, 0, 0, relative)
			end
		end
		if current_object.spawn_sequence == 14 then
			current_object.object[0] = current_object.place_at_me(warthog_turret_rocket, none, never_garbage_collect, 0, 0, 0, none) --Rocket Turret
		end
		if current_object.spawn_sequence == 15 then
			current_object.object[0] = current_object.place_at_me(scorpion_turret_anti_infantry, none, never_garbage_collect, 0, 0, 0, none) 			--Scorpion Turret
		end
		if current_object.spawn_sequence == 16 then
			current_object.object[0] = current_object.place_at_me(wraith_turret_anti_infantry, none, never_garbage_collect, 0, 0, 0, none) 			--Wraith Turret
		end
		if current_object.spawn_sequence == 17 then
			current_object.object[0] = current_object.place_at_me(shade, none, never_garbage_collect, 0, 0, 0, none)
			if current_object.object[0] == no_object then
				current_object.object[0] = current_object.place_at_me(flag_stand, none, never_garbage_collect, 0, 0, 0, none)
			end
			gauss_shade = current_object.object[0]
			gauss_shade.object[0] = current_object.place_at_me(shade_gun_anti_air, none, never_garbage_collect, 0, 0, 0, none) 			--Anti-air Shade Turret
			gauss_shade.object[1] = current_object.place_at_me(flag_stand, none, never_garbage_collect, 0, 0, 0, none)
			current_object.object[0].set_shape(cylinder, 10, 10, 0)
			for each object do
				if gauss_shade.shape_contains(current_object) and current_object.is_of_type(shade_gun_plasma) then
					current_object.delete()
				end
			end
			gauss_shade.object[1].set_scale(1)
			gauss_shade.attach_to(current_object, 0, 0, 0, relative)
			gauss_shade.detach()
			gauss_shade.object[1].attach_to(gauss_shade, 0, 0, 0, relative)
			gauss_shade.object[0].attach_to(gauss_shade.object[1], 0, 0, 0, relative)
			gauss_shade.number[5] = 7825
		end
		if current_object.spawn_sequence == 18 then
			current_object.object[0] = current_object.place_at_me(falcon_turret_grenade_left, none, never_garbage_collect, 0, 0, 0, none) 			--Grenade Launcher Turret Left
		end
		if current_object.spawn_sequence == 19 then
			current_object.object[0] = current_object.place_at_me(falcon_turret_grenade_right, none, never_garbage_collect, 0, 0, 0, none) 			--Grenade Launcher Turret Right
		end
		if current_object.spawn_sequence == 20 then
			current_object.object[0] = current_object.place_at_me(phantom, none, never_garbage_collect, 0, 0, 0, none)						--phantom with turrets
			current_object.object[0].attach_to(current_object, 0, 0, 0, relative)
		end
		if current_object.spawn_sequence == 21 then
			current_object.object[0] = current_object.place_at_me(phantom_device, none, never_garbage_collect, 0, 0, 0, none) 			--Phantom Device (Boneyard)
		end
		if current_object.spawn_sequence == 22 then
			current_object.object[0] = current_object.place_at_me(longsword, none, never_garbage_collect, 0, 0, 0, none) 			--longsword (Boneyard)
		end
		if current_object.spawn_sequence == 23 then
			current_object.object[0] = current_object.place_at_me(unsc_data_core_holder, none, never_garbage_collect, 0, 0, 0, none) 			--Boneyard Core Holder 
		end
		if current_object.spawn_sequence == 24 then
			current_object.object[0] = current_object.place_at_me(covenant_power_module_stand, none, never_garbage_collect, 0, 0, 0, none) 			--Spire Core Holder 
		end
		if current_object.spawn_sequence == 25 then
			current_object.object[0] = current_object.place_at_me(pelican, none, never_garbage_collect, 0, 0, 0, none) 			--Pelican (Spire)
		end
		if current_object.spawn_sequence > 20 then
			current_object.object[0].attach_to(current_object, 0, 0, 0, relative)
			current_object.object[0].detach()
		end
		current_object.object[0].copy_rotation_from(current_object, true)
		if current_object.team == team[0] and current_object.spawn_sequence != -5 then
			current_object.object[0].attach_to(current_object, 0, 0, 0, relative)
		end
	end
	if current_object.spawn_sequence == -2 then --Deletion zone
		current_object.set_shape_visibility(everyone)
		global.object[0] = no_object
		global.object[0] = current_object
		for each object do
			if global.object[0].shape_contains(current_object) and global.object[0] != current_object and not current_object.is_of_type(monitor) then
				current_object.delete()
			end
		end
	end
	if current_object.spawn_sequence == -8 or current_object.spawn_sequence == -9 then --Invincibility Zones
		spawner_obj = current_object
		for each object do
			if spawner_obj.shape_contains(current_object) then
				if spawner_obj.team == current_object.team or spawner_obj.team == neutral_team then
					if spawner_obj.spawn_sequence == -8 then --Invincibility
						current_object.set_invincibility(1)
					end
					if spawner_obj.spawn_sequence == -9 then --Vincibility
						current_object.set_invincibility(0)
					end
				end
			end
		end
	end
	--Animation Device Manipulation--
	if current_object.spawn_sequence == -49 then
		gauss_shade = current_object
		for each object do
			if gauss_shade.shape_contains(current_object) then
				current_object.set_device_power(100)
			end
		end
	end
	if current_object.spawn_sequence < -49 then
		gauss_shade = current_object
		temp_int2 = current_object.spawn_sequence
		temp_int2 *= -1
		for each object with label "spawner" do --This is a switch
			if current_object.spawn_sequence == temp_int2 and gauss_shade.object[3] == no_object then --Absolute value
				gauss_shade.object[3] = current_object 
				if gauss_shade.number[4] == 0 then
					gauss_shade.number[4] = 1111
				end
				gauss_shade.number[3] = 1
			end
		end
		--Handle the switch--
		if current_object.object[3] == no_object then
			if current_object.number[3] == 1 then
				current_object.number[4] *= -1
				current_object.number[3] = 2 --Only "flips" the number once
			end
		end
		for each object do
			if gauss_shade.shape_contains(current_object) then
				if gauss_shade.number[4] == 0 then --No switch, just a zone
					for each player do
						if gauss_shade.shape_contains(current_player.biped) then
							current_object.set_device_power(100)
							current_object.set_device_position(100)
						end
					end
				end
				if gauss_shade.number[4] == -1111 then --The switch has been hit. If it's hit again, the device position naturally returns to 0
					current_object.set_device_power(100)
					current_object.set_device_position(100)
				end
			end
		end
	end
end

---== LOCAL TRIGGERS ==--- 

 on local: do
	--== 330x ==--
	for each object with label "scale" do
		if current_object.obj_scale == 0 then 
		   current_object.obj_scale = 100
		   recursions = current_object.spawn_sequence
		   if current_object.spawn_sequence < 0 then 
			  recursions *= 5
			  current_object.obj_scale += recursions
			  if current_object.spawn_sequence <= -20 then 
				 recursions = current_object.spawn_sequence
				 recursions += 201
				 if current_object.spawn_sequence == -20 then 
					current_object.obj_scale = 1
				 end
			  end
		   end
		   if current_object.spawn_sequence < -20 or current_object.spawn_sequence > 0 then 
			  current_object.obj_scale = 100
			  optimized_330x()
		   end
		   current_object.set_scale(current_object.obj_scale)
		   current_object.copy_rotation_from(current_object, false)
  -------------- 
  -- OPTIONAL --
  --------------
		   -- purple team makes the object phased, have no collision, & have infinite health & shields.
		   -- green team does the same and also makes the object cast a shadow
		   if current_object.team == team[4] or current_object.team == team[2] then
			   -- condition is to ensure only host creates a flag stand, tho I haven't confirmed if clients ever create their own. They only would if there's some delay in host telling them the object's object[0] exists.
			   if master_hill_marker.is_of_type(hill_marker) then 
				   anchor = current_object.place_between_me_and(current_object, flag_stand, 0)
				   anchor.set_scale(1)
				   if current_object.team == team[2] then
					 anchor.delete()
					  anchor = current_object.place_between_me_and(current_object, heavy_barrier, 0)
					  anchor.set_scale(50)		-- if shadow is too pixelated, increase this value or remove it entirely.
					   if anchor == no_object then
						  anchor = current_object.place_between_me_and(current_object, warthog_turret, 0)	-- for non-forge-world maps that can't spawn warthogs
					   end
				   end
				   current_object.attach_to(anchor, 0,0,0,relative)
				 -- make unkillable
				   global.number[10] = current_object.health
				 if global.number[10] == 100 then			-- condition necessary to prevent non-health purple/green team scale objects overloading maps.
					  current_object.max_health *= 5000
					  current_object.health = 100
				  end
			   end
		   end
		end
	 end
	--== FRONTLINES ==--
	-- Ability widgets
	for each player do
		if current_player.ability_timer == 0 then
			script_widget[0].set_visibility(current_player, false)
			script_widget[1].set_visibility(current_player, false)
		end
		temp_object = current_player.biped
		if temp_object.class == class.major and current_player.ability_timer > 0 then
			script_widget[0].set_visibility(current_player, true)
			script_widget[0].set_text("OVERCHARGE %n\r\nWeapons won't overheat", hud_player.ability_timer)
		end
		if temp_object.class == class.ultra and current_player.ability_timer > 0 then
			script_widget[1].set_visibility(current_player, true)
			script_widget[1].set_text("BERSERK %n", hud_player.ability_timer)
		end
		if current_player.player[0] == no_player then
			script_widget[2].set_visibility(current_player, false)
		end
	end
 end